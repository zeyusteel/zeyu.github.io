---
title: C++ 继承
date: 2020-08-10 10:00:00
tags:
    - C++
---

## C++特性
抽象 封装 继承 多态

## 成员类型

- 公有成员类型

    任何外部的函数都可以访问共有类型数据和函数

    是类与外部的接口

- 私有类型成员

    只允许本类中的函数访问，类外的任何函数不能访问

    不写关键字，默认为私有成员

- 保护成员

    与私有很像，差别在继承与派生时对派生类的影响不同

## 内联成员函数

    直接在类内写函数

    使用inline关键字


## 拷贝构造函数

    class 类名{
    public:
        类名（const 类名 &对象名）；
    }

    类名::类名（const 类名 &对象名）
    {
    }

## 析构函数

    ~类名（）

## 友元
友元都是单向的

## 友元函数

    声明类外函数为本类朋友

## 友元类

    friend class B;  (对B类授权可以访问自己)

## 继承
### 概念
继承与派生概述

- 继承与派生是同一过程从不同的角度看
  - 保持已有类的特性而构造新类的过程称为继承
  - 在已有类的基础上新增自己的特性而产生新类的过程称为派生
- 被继承的已有类称为基类（或父类）
- 派生出的新类称为派生类（或子类）
- 直接参与派生出某类的基类称为直接基类
- 基类的基类甚至更高层的基类称为间接基类

派生是为了解决原有程序无法完全解决问题，对程序的改造

派生类的构成
- 吸收基类成员
- 改造基类成员
  - 如果派生类声明了一个和某基类成员同名的新成员，派生的新成员就隐藏或覆盖了外层同名成员
- 添加新的成员

### 继承方式

- 公有继承
  - 继承的访问控制
    - 基类的`public`和`protected`成员:访问属性在派生类中**保持不变** 
    - 基类的`private`成员:不可直接访问
  - 访问权限
    - 派生类中的成员函数:可以直接访问基类中的`public`和`protected`成员,但不能直接访问基类的`private`成员
    - 通过派生类的对象:只能访问`public`成员。

- 私有继承
  - 继承的访问控制
      - 基类的`public`和`protected`成员:都以`private`身份出现在派生类中
      - 基类的`private`成员:不可以直接访问
  - 访问权限
    - 派生类中的成员函数:可以直接访问基类中的`public`和`protected`成员,但不能直接访问基类的`private`成员
    - 通过派生类的对象:不能直接访问从基类继承的任何成员

- 保护继承
  - 继承的访问控制
      - 基类的`public`和`protected`成员:都以`protected`身份出现在派生类中
      - 基类的`private`成员:不可以直接访问
  - 访问权限
    - 派生类中的成员函数:可以直接访问基类中的`public`和`protected`成员,但不能直接访问基类的`private`成员
    - 通过派生类的对象:不能直接访问从基类继承的任何成员

**不要重新定义继承来的非虚函数**

## 派生类的构造函数
基类的构造函数不被继承,派生类需要编写自己的构造函数

### 单继承时构造函数

    派生类名:派生类名(基类所需的型参,本类成员所需的型参):基类名(参数表),本类成员初始化列表 
    {
        //其他初始化
    }

### 多继承时构造函数

    派生类名:派生类名(参数表):基类名1(基类1初始化参数表),基类名2(基类2初始化参数表),基类名n(基类n初始化参数表),本类成员初始化列表 
    {
        //其他初始化
    }

### 构造函数的执行顺序
1. 调用基类的构造函数,
    - 顺序按照它们被继承时声明的顺序(从左向右)
2. 对初始化列表中的成员进行初始化
    - 顺序按照它们在类中定义的顺序
    - 对象成员初始化时自动调用其所属类的构造函数,由初始化列表提供参数
3. 执行派生类的构造函数体中的内容


```c++
class Demo : public BaseB, public BaseA { //顺序 BaseB -> BaseA
public:
    Demo(int a, std::string str) : BaseA(), BaseB(),  //和这里的顺序无关
        m_a(a),
        m_b(str) {

    }
private:       //顺序 m_a ->  m_b
    CItemA m_a;
    CItemB m_b;
};

```

**析构函数与构造函数顺序相反**